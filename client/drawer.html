<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Canvas Paint App</title>
	 <style>
      body {
         background: #eeeeee;
         font-family: tahoma, verdana, sans serif;
      }

      #mainCanvas {
         background: #ffffff;
         position:absolute;
         z-index: 0;
         left: 10px;
         top: 10px;
         box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
      }
      
      
       #controls {
         position: absolute;
          z-index: 2;
         left: 25px;
         top: 25px;
      }
	  #topCanvas{
		background: rgba(0,0,0,0);
		position: absolute;
		left: 10px;
		top: 10px;
		z-index: 1;
		cursor: pointer;
	  }
      
      label{
      	font-size: 12px;
      	margin-right:0.75em;
      }
      
    </style>
     <script src="/socket.io/socket.io.js"></script>
	<script>
	"use strict";
	
	// GLOBALS
	let canvas,ctx,dragging=false,lineWidth,strokeStyle,currentTool,fillStyle,origin,topCanvas,topCtx;
	let socket;
	// CONSTANTS
	let DEFAULT_LINE_WIDTH = 3;
	const DEFAULT_STROKE_STYLE = "red";
	const DEFAULT_FILL_STYLE = "blue";
	let TOOL_PENCIL ="toolPencil";
	let TOOL_RECTANGLE = "toolRectangle";
	let TOOL_LINE = "toolLine";
	
	
	const init = () =>{
		// initialize some globals
		canvas = document.querySelector('#mainCanvas');
		ctx = canvas.getContext('2d');
		topCanvas = document.querySelector('#topCanvas');
		topCtx = topCanvas.getContext('2d')
		topCtx.lineWidth = ctx.lineWidth = lineWidth;
		topCtx.strokeStyle = ctx.strokeStyle = strokeStyle;
		topCtx.fillStyle = ctx.fillStyle = fillStyle;
		topCtx.lineCap = ctx.lineCap = "round";
		topCtx.lineJoin = ctx.lineJoin = "round";
		fillStyle = DEFAULT_FILL_STYLE;
		currentTool = TOOL_PENCIL;
		origin = {};
		
		drawGrid(ctx,'lightgray',5,5);
		
		topCanvas.onmousedown = doMousedown;
		topCanvas.onmousemove = doMousemove;
		topCanvas.onmouseup = doMouseup;
		topCanvas.onmouseout = doMouseout;

		document.querySelector('#lineWidthChooser').onchange = doLineWidthChange;				
		document.querySelector('#fillStyleChooser').onchange = doStrokeStyleChange;
		document.querySelector('#clearButton').onclick = doClear;
		document.querySelector('#toolChooser').onchange = function(e)
		{
			currentTool = e.target.value;
			console.log("currentTool =" + currentTool);
		}
		document.querySelector('#fillStyleChooser').onchange = function(e)
			{
				if(e.target.value == "gradient"){
				var grad = ctx.createLinearGradient(10, 0, 700, 0);
				grad.addColorStop(0, 'red');
				grad.addColorStop(1 / 6, 'orange');
				grad.addColorStop(2 / 6, 'yellow');
				grad.addColorStop(3 / 6, 'green')
				grad.addColorStop(4 / 6, 'aqua');
				grad.addColorStop(5 / 6, 'blue');
				grad.addColorStop(1, 'purple');
				fillStyle = grad;
				
				}
				else{
				fillStyle = e.target.value;
				}
			}
			
            //Connect to our server
            socket = io.connect();
            
            //When the socket connects successfully
            socket.on('connect', () => {
				var socketid = socket;
				socket.emit('ready');
            });      
			
			//handle server response
            socket.on('start', countDown);
            socket.on('end', snapshot);
			socket.on('scorereset',doClear);

		}

	
	
	// EVENT CALLBACK FUNCTIONS
	const doMousedown = (e) =>{
		console.log(e.type);
		dragging= true;
		
		var mouse = getMouse(e);
		switch(currentTool){
		case TOOL_PENCIL:
			ctx.beginPath();
			ctx.moveTo(mouse.x,mouse.y);
			break;
			
		case TOOL_RECTANGLE:
		case TOOL_LINE:
			origin.x = mouse.x;
			origin.y = mouse.y;
			break;
		}
	}
 
 	const doMousemove = (e) => {
 		if(! dragging) return;
		
		var mouse = getMouse(e)
		
		switch(currentTool){
		case TOOL_PENCIL:
			ctx.strokeStyle = strokeStyle;
			ctx.lineWidth = lineWidth;
			ctx.lineTo(mouse.x,mouse.y);
			ctx.stroke();
			break;
		case TOOL_RECTANGLE:
			let x = Math.min(mouse.x,origin.x);
			let y = Math.min(mouse.y, origin.y);
			let w = Math.abs(mouse.x - origin.x);
			let h = Math.abs(mouse.y - origin.y);
			
			topCtx.strokeStyle = strokeStyle;
			topCtx.fillStyle = fillStyle;
			topCtx.lineWidth = lineWidth;
			
			clearTopCanvas();
			topCtx.fillRect(x,y,w,h);
			topCtx.strokeRect(x,y,w,h);
			break;
			
		case TOOL_LINE:
			topCtx.strokeStyle = strokeStyle;
			topCtx.lineWidth = lineWidth;
			clearTopCanvas();
			topCtx.beginPath();
			topCtx.moveTo(origin.x,origin.y);
			topCtx.lineTo(mouse.x,mouse.y);
			topCtx.stroke();
			break;
		}
	}
	
	const doMouseup = (e) =>{
		switch(currentTool){
			case TOOL_PENCIL:
				ctx.closePath();
				break;
			case TOOL_RECTANGLE:
			case TOOL_LINE:
				if(dragging){
					ctx.drawImage(topCanvas,0,0);
					clearTopCanvas()
				}
				break;
		}
		dragging = false;
	}
	const clearTopCanvas = () =>{
		topCtx.clearRect(0,0,topCtx.canvas.width,topCtx.canvas.height);
	}
	
	// if the user drags out of the canvas
	const doMouseout = (e) =>{
		switch(currentTool){
			case TOOL_PENCIL:
			ctx.closePath();
				break;
			case TOOL_RECTANGLE:
			case TOOL_LINE:
				clearTopCanvas()
				break;
		}
		dragging = false;
	}
	
	const doClear = () =>{
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		drawGrid(ctx,'lightgray', 5, 5);
	}
	const doLineWidthChange = (e) =>{
		lineWidth = e.target.value;
	}
	const doStrokeStyleChange = (e) =>{
		strokeStyle = e.target.value;
	}
	const doFillStyleChange = (e) => {
		fillStyle = e.target.value;
	}
	
	const snapshot = () =>{

		var data = canvas.toDataURL(); 
		socket.emit('snapshot', {imgData: data});
	 }
	
	const getMouse = (e) =>{
		var mouse = {}
		mouse.x = e.pageX - e.target.offsetLeft;
		mouse.y = e.pageY - e.target.offsetTop;
		return mouse;
	}
		const drawGrid =(ctx, color, cellWidth, cellHeight)=>{
		// save the current drawing state as it existed before this function was called
		ctx.save()
		
		// set some drawing state variables
		ctx.strokeStyle = color;
		ctx.fillStyle = '#ffffff';
		ctx.lineWidth = 0.5;
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		
		// vertical lines all set!
		for (var x = cellWidth + ctx.lineWidth; x < ctx.canvas.width; x += cellWidth) {
			ctx.beginPath();
			ctx.moveTo(x, 0);
			ctx.lineTo(x, ctx.canvas.height);
			ctx.stroke();
		}
		
		for (var y = cellHeight + ctx.lineWidth; y < ctx.canvas.height; y += cellHeight) {
			ctx.beginPath();
			ctx.moveTo(0,y);
			ctx.lineTo(ctx.canvas.width, y);
			ctx.stroke();
		}
		
		
		// restore the drawing state
		ctx.restore();
	}
	
	const countDown = () => {
	    var countdownElement = document.getElementById('countdown'),
        seconds = 10,
        second = 0,
        interval;

    interval = setInterval(function() {
        countdownElement.innerHTML = 'Draw! ' + (seconds - second) + ' seconds left';
        if (second >= seconds) {
            clearInterval(interval);
			socket.emit('timesUP');
        }
		console.log(second);
        second++;
    }, 1000);
	}
		window.onload = init;

	</script>
</head>
<body>
	<div style="background: yellow">
	<canvas id="mainCanvas" width="900" height="700">
	Get a real browser!
	</canvas>
	<canvas id="topCanvas" width="900" height="700">
	Get a real browser!
	</canvas>
	<div id="controls">
		<label>Tool:
			<select id="toolChooser">
				<option value="toolPencil">Pencil</option>
				<option value="toolRectangle">Rectangle</option>
				<option value="toolLine">Line</option>
    		</select>
    	</label>
    	
    	<label>Line Width: 
			<select id="lineWidthChooser">
				<option value="1">1</option>
				<option value="2">2</option>
        		<option value="3" selected>3</option>
        		<option value="4">4</option>
				<option value="5">5</option>
        		<option value="6">6</option>
        		<option value="7">7</option>
				<option value="8">8</option>
        		<option value="9">9</option>
        		<option value="10">10</option>
    		</select>
    	</label>
    	    	<label>Stroke Color: 
			<select id="strokeStyleChooser">
				<option value="Black" selected>Black</option>
				<option value="Blue">Blue</option>
        		<option value="Red">Red</option>
        		<option value="Yellow">Yellow</option>
				<option value="Green">Green</option>
        		<option value="Orange">Orange</option>
        		<option value="Purple">Purple</option>
				<option value="White">White</option>
        		<option value="Silver">Silver</option>
        		<option value="Brown">Brown</option>
    		</select>
    	</label>
		     	<label>Fill Color: 
			<select id="fillStyleChooser">
				<option value="Black">Black</option>
				<option value="Blue"selected>Blue</option>
        		<option value="Red">Red</option>
        		<option value="Yellow">Yellow</option>
				<option value="Green">Green</option>
        		<option value="Orange">Orange</option>
        		<option value="Purple">Purple</option>
				<option value="White">White</option>
        		<option value="gradient">gradient</option>
        		<option value="Brown">Brown</option>
    		</select>
    	</label>
    	
    	<span><input id="clearButton" type="button" value="Clear"/></span>
		<span><p id="countdown">Timer has not begun</p></span>
    </div>
	<div style="width: 29%; height: 100%; margin-left: 910px">
	<div style="padding: 5px; background: red; height: 100px;" id="subject">
		<h4>Thing to Draw:</h4>
		<p>Turtle</p>
	</div>
	<div style="padding: 5px; background: blue; height:590px;" id="feed">
		<h4>Who won round, scores</h4>
		
	</div>
	</div>
	</div>
</body>
</html>
